//
//  GeneratorTests.swift
//  WeaverCodeGenTests
//
//  Created by Th√©ophane Rupin on 3/4/18.
//

import Foundation
import XCTest
import SourceKittenFramework
import PathKit

@testable import WeaverCodeGen

final class GeneratorTests: XCTestCase {
    
    private let templatePath = Path(#file).parent() + Path("../../Resources/dependency_resolver.stencil")
    
    func test_generator_should_return_nil_when_no_annotation_is_detected() {
        
        do {
            let file = File(contents: """
final class MyService {
  let dependencies: DependencyResolver

  init(_ dependencies: DependencyResolver) {
    self.dependencies = dependencies
  }
}
""")
            
            let lexer = Lexer(file, fileName: "test.swift")
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens, fileName: "test.swift")
            let ast = try parser.parse()
            
            let generator = try Generator(asts: [ast], template: templatePath)
            let (_ , actual) = try generator.generate().first!

            XCTAssertNil(actual)
            
        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
    
    func test_generator_should_generate_a_valid_swift_code_when_an_empty_type_gets_registered() {
        
        do {
            let file = File(contents: """
final class Logger {
    func log(_ message: String) { print(message) }

    // weaver: logEngine = LogEngine
}

final class Manager {
    // weaver: logger = Logger
}
""")
            
            let lexer = Lexer(file, fileName: "test.swift")
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens, fileName: "test.swift")
            let ast = try parser.parse()
            
            let generator = try Generator(asts: [ast], template: templatePath)
            let (_ , actual) = try generator.generate().first!
            
            let expected = """
/// This file is generated by Weaver 0.9.12
/// DO NOT EDIT!
import WeaverDI
// MARK: - Logger
final class LoggerDependencyContainer: DependencyContainer {
    init() {
        super.init()
    }
    override func registerDependencies(in store: DependencyStore) {
        store.register(LogEngine.self, scope: .graph, name: "logEngine", builder: { (dependencies) in
            return LogEngine()
        })
    }
}
protocol LoggerDependencyResolver {
    var logEngine: LogEngine { get }
}
extension LoggerDependencyContainer: LoggerDependencyResolver {
    var logEngine: LogEngine {
        return resolve(LogEngine.self, name: "logEngine")
    }
}
// MARK: - Manager
final class ManagerDependencyContainer: DependencyContainer {
    init() {
        super.init()
    }
    override func registerDependencies(in store: DependencyStore) {
        store.register(Logger.self, scope: .graph, name: "logger", builder: { (dependencies) in
            return Logger()
        })
    }
}
protocol ManagerDependencyResolver {
    var logger: Logger { get }
}
extension ManagerDependencyContainer: ManagerDependencyResolver {
    var logger: Logger {
        return resolve(Logger.self, name: "logger")
    }
}
"""
            
            XCTAssertEqual(actual!, expected)
            exportDiff(actual: actual!, expected: expected)

        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
    
    func test_generator_should_generate_a_valid_swift_code_when_an_isolated_type_gets_registered() {
        
        do {
            let file = File(contents: """
final class PersonManager: PersonManaging {

    // weaver: self.isIsolated = true

    // weaver: logger = Logger
    
    // weaver: movieAPI <- APIProtocol
}
""")
            
            let lexer = Lexer(file, fileName: "test.swift")
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens, fileName: "test.swift")
            let ast = try parser.parse()
            
            let generator = try Generator(asts: [ast], template: templatePath)
            let (_ , actual) = try generator.generate().first!
            
            let expected = """
/// This file is generated by Weaver 0.9.12
/// DO NOT EDIT!
import WeaverDI
// MARK: - PersonManager
protocol PersonManagerDependencyResolver {
    var logger: Logger { get }
    var movieAPI: APIProtocol { get }
}
protocol PersonManagerDependencyInjectable {
    init(injecting dependencies: PersonManagerDependencyResolver)
}
extension PersonManager: PersonManagerDependencyInjectable {}
"""
            
            XCTAssertEqual(actual!, expected)
            exportDiff(actual: actual!, expected: expected)

        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
    
    func test_generator_should_generate_a_valid_swift_code_with_a_customRef() {
        
        do {
            let file = File(contents: """
final class PersonManager: PersonManaging {
    // weaver: movieAPI = MovieAPI <- APIProtocol
    // weaver: movieAPI.customRef = true
}
""")
            
            let lexer = Lexer(file, fileName: "test.swift")
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens, fileName: "test.swift")
            let ast = try parser.parse()
            
            let generator = try Generator(asts: [ast], template: templatePath)
            let (_ , actual) = try generator.generate().first!
            
            let expected = """
/// This file is generated by Weaver 0.9.12
/// DO NOT EDIT!
import WeaverDI
// MARK: - PersonManager
final class PersonManagerDependencyContainer: DependencyContainer {
    init() {
        super.init()
    }
    override func registerDependencies(in store: DependencyStore) {
        store.register(APIProtocol.self, scope: .graph, name: "movieAPI", builder: { (dependencies) in
            return self.movieAPICustomRef()
        })
    }
}
protocol PersonManagerDependencyResolver {
    var movieAPI: APIProtocol { get }
    func movieAPICustomRef() -> APIProtocol
}
extension PersonManagerDependencyContainer: PersonManagerDependencyResolver {
    var movieAPI: APIProtocol {
        return resolve(APIProtocol.self, name: "movieAPI")
    }
}
"""
            
            XCTAssertEqual(actual!, expected)
            exportDiff(actual: actual!, expected: expected)

        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
    
    func test_generator_should_generate_a_valid_swift_code_with_a_customRef_taking_parameters() {
        
        do {
            let file = File(contents: """
final class MovieAPI {
    // weaver: host <= String
}

final class PersonManager: PersonManaging {
    // weaver: movieAPI = MovieAPI <- APIProtocol
    // weaver: movieAPI.customRef = true
}
""")
            
            let lexer = Lexer(file, fileName: "test.swift")
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens, fileName: "test.swift")
            let ast = try parser.parse()
            
            let generator = try Generator(asts: [ast], template: templatePath)
            let (_ , actual) = try generator.generate().first!
            
            let expected = """
/// This file is generated by Weaver 0.9.12
/// DO NOT EDIT!
import WeaverDI
// MARK: - MovieAPI
final class MovieAPIDependencyContainer: DependencyContainer {
    let host: String
    init(parent: DependencyContainer? = nil, host: String) {
        self.host = host
        super.init(parent)
    }
    override func registerDependencies(in store: DependencyStore) {
    }
}
protocol MovieAPIDependencyResolver {
    var host: String { get }
}
extension MovieAPIDependencyContainer: MovieAPIDependencyResolver {
}
extension MovieAPI {
    static func makeMovieAPI(injecting parentDependencies: DependencyContainer, host: String) -> MovieAPI {
        let dependencies = MovieAPIDependencyContainer(parent: parentDependencies, host: host)
        return MovieAPI(injecting: dependencies)
    }
}
protocol MovieAPIDependencyInjectable {
    init(injecting dependencies: MovieAPIDependencyResolver)
}
extension MovieAPI: MovieAPIDependencyInjectable {}
// MARK: - PersonManager
final class PersonManagerDependencyContainer: DependencyContainer {
    init() {
        super.init()
    }
    override func registerDependencies(in store: DependencyStore) {
        store.register(APIProtocol.self, scope: .graph, name: "movieAPI", builder: { (dependencies, host: String) in
            return self.movieAPICustomRef(host: host)
        })
    }
}
protocol PersonManagerDependencyResolver {
    func movieAPI(host: String) -> APIProtocol
    func movieAPICustomRef(host: String) -> APIProtocol
}
extension PersonManagerDependencyContainer: PersonManagerDependencyResolver {
    func movieAPI(host: String) -> APIProtocol {
        return resolve(APIProtocol.self, name: "movieAPI", parameter: host)
    }
}
"""
            
            XCTAssertEqual(actual!, expected)
            exportDiff(actual: actual!, expected: expected)

        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
    
    func test_generator_should_generate_a_valid_swift_code_with_embedded_injectable_types() {
        
        do {
            let file = File(contents: """
final class MyService {
  // weaver: session = Session

  final class MyEmbeddedService {

    // weaver: session = Session? <- SessionProtocol?
    // weaver: session.scope = .container
  }
}
""")
            
            let lexer = Lexer(file, fileName: "test.swift")
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens, fileName: "test.swift")
            let ast = try parser.parse()
            
            let generator = try Generator(asts: [ast], template: templatePath)
            let (_ , actual) = try generator.generate().first!
            
            let expected = """
/// This file is generated by Weaver 0.9.12
/// DO NOT EDIT!
import WeaverDI
// MARK: - MyService
final class MyServiceDependencyContainer: DependencyContainer {
    init() {
        super.init()
    }
    override func registerDependencies(in store: DependencyStore) {
        store.register(Session.self, scope: .graph, name: "session", builder: { (dependencies) in
            return Session()
        })
    }
}
protocol MyServiceDependencyResolver {
    var session: Session { get }
}
extension MyServiceDependencyContainer: MyServiceDependencyResolver {
    var session: Session {
        return resolve(Session.self, name: "session")
    }
}
// MARK: - MyEmbeddedService
final class MyEmbeddedServiceDependencyContainer: DependencyContainer {
    init() {
        super.init()
    }
    override func registerDependencies(in store: DependencyStore) {
        store.register(SessionProtocol?.self, scope: .container, name: "session", builder: { (dependencies) in
            return Session()
        })
    }
}
protocol MyEmbeddedServiceDependencyResolver {
    var session: SessionProtocol? { get }
}
extension MyEmbeddedServiceDependencyContainer: MyEmbeddedServiceDependencyResolver {
    var session: SessionProtocol? {
        return resolve(SessionProtocol?.self, name: "session")
    }
}
"""
            
            XCTAssertEqual(actual!, expected)
            exportDiff(actual: actual!, expected: expected)

        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
    
    func test_generator_should_generate_a_valid_swift_code_with_a_public_injectableType() {
        
        do {
            let file = File(contents: """
public final class API {
  // weaver: session = Session
  // weaver: logger <- Logger
  // weaver: host <= String
}
""")
            
            let lexer = Lexer(file, fileName: "test.swift")
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens, fileName: "test.swift")
            let ast = try parser.parse()
            
            let generator = try Generator(asts: [ast], template: templatePath)
            let (_ , actual) = try generator.generate().first!
            
            let expected = """
/// This file is generated by Weaver 0.9.12
/// DO NOT EDIT!
import WeaverDI
// MARK: - API
final class APIDependencyContainer: DependencyContainer {
    let host: String
    init(parent: DependencyContainer? = nil, host: String) {
        self.host = host
        super.init(parent)
    }
    override func registerDependencies(in store: DependencyStore) {
        store.register(Session.self, scope: .graph, name: "session", builder: { (dependencies) in
            return Session()
        })
    }
}
protocol APIDependencyResolver {
    var host: String { get }
    var session: Session { get }
    var logger: Logger { get }
}
extension APIDependencyContainer: APIDependencyResolver {
    var session: Session {
        return resolve(Session.self, name: "session")
    }
    var logger: Logger {
        return resolve(Logger.self, name: "logger")
    }
}
extension API {
    static func makeAPI(injecting parentDependencies: DependencyContainer, host: String) -> API {
        let dependencies = APIDependencyContainer(parent: parentDependencies, host: host)
        return API(injecting: dependencies)
    }
}
protocol APIDependencyInjectable {
    init(injecting dependencies: APIDependencyResolver)
}
extension API: APIDependencyInjectable {}
// MARK: - APIShim
final class APIShimDependencyContainer: DependencyContainer {
    private lazy var internalDependencies: APIDependencyContainer = {
        return APIDependencyContainer(parent: self, host: self.host)
    }()
    let logger: Logger
    let host: String
    init(logger: Logger, host: String) {
        self.logger = logger
        self.host = host
        super.init()
    }
    override func registerDependencies(in store: DependencyStore) {
        store.register(Logger.self, scope: .container, name: "logger", builder: { _ in
            return self.logger
        })
    }
}
extension APIShimDependencyContainer: APIDependencyResolver {
    var session: Session {
        return internalDependencies.resolve(Session.self, name: "session")
    }
}
extension API {
    public convenience init(logger: Logger, host: String) {
        let shim = APIShimDependencyContainer(logger: logger, host: host)
        self.init(injecting: shim)
    }
}
"""
            
            XCTAssertEqual(actual!, expected)
            exportDiff(actual: actual!, expected: expected)

        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
    
    func test_generator_should_generate_a_valid_swift_code_with_ignored_types() {
        
        do {
            let file = File(contents: """
final class API: APIProtocol {
    // weaver: parameter <= UInt
}

class AnotherService {
    // This class is ignored
}
""")
            
            let lexer = Lexer(file, fileName: "test.swift")
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens, fileName: "test.swift")
            let ast = try parser.parse()
            
            let generator = try Generator(asts: [ast], template: templatePath)
            let (_ , actual) = try generator.generate().first!
            
            let expected = """
/// This file is generated by Weaver 0.9.12
/// DO NOT EDIT!
import WeaverDI
// MARK: - API
final class APIDependencyContainer: DependencyContainer {
    let parameter: UInt
    init(parent: DependencyContainer? = nil, parameter: UInt) {
        self.parameter = parameter
        super.init(parent)
    }
    override func registerDependencies(in store: DependencyStore) {
    }
}
protocol APIDependencyResolver {
    var parameter: UInt { get }
}
extension APIDependencyContainer: APIDependencyResolver {
}
extension API {
    static func makeAPI(injecting parentDependencies: DependencyContainer, parameter: UInt) -> API {
        let dependencies = APIDependencyContainer(parent: parentDependencies, parameter: parameter)
        return API(injecting: dependencies)
    }
}
protocol APIDependencyInjectable {
    init(injecting dependencies: APIDependencyResolver)
}
extension API: APIDependencyInjectable {}
"""
            XCTAssertEqual(actual!, expected)
            exportDiff(actual: actual!, expected: expected)
            
        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
    
    func test_generator_should_generate_a_valid_swift_code_with_internal_type_with_one_parameter_being_registered_in_a_public_type() {
        
        do {
            let file = File(contents: """
final class Logger {
    // weaver: domain <= String
}
public final class MovieManager {
    // weaver: logger = Logger
}
""")
            
            let lexer = Lexer(file, fileName: "test.swift")
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens, fileName: "test.swift")
            let ast = try parser.parse()
            
            let generator = try Generator(asts: [ast], template: templatePath)
            let (_ , actual) = try generator.generate().first!
            
            let expected = """
/// This file is generated by Weaver 0.9.12
/// DO NOT EDIT!
import WeaverDI
// MARK: - Logger
final class LoggerDependencyContainer: DependencyContainer {
    let domain: String
    init(parent: DependencyContainer? = nil, domain: String) {
        self.domain = domain
        super.init(parent)
    }
    override func registerDependencies(in store: DependencyStore) {
    }
}
protocol LoggerDependencyResolver {
    var domain: String { get }
}
extension LoggerDependencyContainer: LoggerDependencyResolver {
}
extension Logger {
    static func makeLogger(injecting parentDependencies: DependencyContainer, domain: String) -> Logger {
        let dependencies = LoggerDependencyContainer(parent: parentDependencies, domain: domain)
        return Logger(injecting: dependencies)
    }
}
protocol LoggerDependencyInjectable {
    init(injecting dependencies: LoggerDependencyResolver)
}
extension Logger: LoggerDependencyInjectable {}
// MARK: - MovieManager
final class MovieManagerDependencyContainer: DependencyContainer {
    init() {
        super.init()
    }
    override func registerDependencies(in store: DependencyStore) {
        store.register(Logger.self, scope: .graph, name: "logger", builder: { (dependencies, domain: String) in
            return Logger.makeLogger(injecting: dependencies, domain: domain)
        })
    }
}
protocol MovieManagerDependencyResolver {
    func logger(domain: String) -> Logger
}
extension MovieManagerDependencyContainer: MovieManagerDependencyResolver {
    func logger(domain: String) -> Logger {
        return resolve(Logger.self, name: "logger", parameter: domain)
    }
}
// MARK: - MovieManagerShim
final class MovieManagerShimDependencyContainer: DependencyContainer {
    private lazy var internalDependencies: MovieManagerDependencyContainer = {
        return MovieManagerDependencyContainer(parent: self)
    }()
    init() {
        super.init()
    }
    override func registerDependencies(in store: DependencyStore) {
    }
}
extension MovieManagerShimDependencyContainer: MovieManagerDependencyResolver {
    func logger(domain: String) -> Logger {
        return internalDependencies.resolve(Logger.self, name: "logger", parameter: domain)
    }
}
extension MovieManager {
    public convenience init() {
        let shim = MovieManagerShimDependencyContainer()
        self.init(injecting: shim)
    }
}
"""
            
            XCTAssertEqual(actual!, expected)
            exportDiff(actual: actual!, expected: expected)
            
        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
    
    func test_generator_should_generate_a_valid_swift_code_with_type_registering_a_generic_dependency() {
        
        do {
            let file = File(contents: """
final class MovieManager {
    // weaver: logger = Logger<String>
}
final class Logger<T> {
    // weaver: domain <= String
}
""")
            
            let lexer = Lexer(file, fileName: "test.swift")
            let tokens = try lexer.tokenize()
            let parser = Parser(tokens, fileName: "test.swift")
            let ast = try parser.parse()
            
            let generator = try Generator(asts: [ast], template: templatePath)
            let (_ , actual) = try generator.generate().first!
            
            let expected = """
/// This file is generated by Weaver 0.9.12
/// DO NOT EDIT!
import WeaverDI
// MARK: - MovieManager
final class MovieManagerDependencyContainer: DependencyContainer {
    init() {
        super.init()
    }
    override func registerDependencies(in store: DependencyStore) {
        store.register(Logger<String>.self, scope: .graph, name: "logger", builder: { (dependencies, domain: String) in
            return Logger<String>.makeLogger(injecting: dependencies, domain: domain)
        })
    }
}
protocol MovieManagerDependencyResolver {
    func logger(domain: String) -> Logger<String>
}
extension MovieManagerDependencyContainer: MovieManagerDependencyResolver {
    func logger(domain: String) -> Logger<String> {
        return resolve(Logger<String>.self, name: "logger", parameter: domain)
    }
}
// MARK: - Logger
final class LoggerDependencyContainer<T>: DependencyContainer {
    let domain: String
    init(parent: DependencyContainer? = nil, domain: String) {
        self.domain = domain
        super.init(parent)
    }
    override func registerDependencies(in store: DependencyStore) {
    }
}
protocol LoggerDependencyResolver {
    associatedtype T
    var domain: String { get }
}
extension LoggerDependencyContainer: LoggerDependencyResolver {
}
extension Logger {
    static func makeLogger(injecting parentDependencies: DependencyContainer, domain: String) -> Logger<T> {
        let dependencies = LoggerDependencyContainer<T>(parent: parentDependencies, domain: domain)
        return Logger(injecting: dependencies)
    }
}
protocol LoggerDependencyInjectable {
    associatedtype T
    init(injecting dependencies: LoggerDependencyContainer<T>)
}
extension Logger: LoggerDependencyInjectable {}
"""
            
            XCTAssertEqual(actual!, expected)
            exportDiff(actual: actual!, expected: expected)
            
        } catch {
            XCTFail("Unexpected error \(error)")
        }
    }
}

// MARK: - Diff Tools

private extension GeneratorTests {
    
    func exportDiff(actual: String, expected: String, _ function: StringLiteralType = #function) {
        
        guard actual != expected else { return }

        let dirPath = "/tmp/weaver_tests/\(GeneratorTests.self)"
        let function = function.split(separator: "(").first ?? ""
        let actualFilePath = "\(dirPath)/\(function)_actual.swift"
        let expectedFilePath = "\(dirPath)/\(function)_expected.swift"

        guard let actualData = actual.data(using: .utf8),
              let expectedData = expected.data(using: .utf8) else {
            XCTFail("Could not convert string to utf8")
            return
        }

        let fileManager = FileManager.default

        do {
            try fileManager.createDirectory(atPath: dirPath, withIntermediateDirectories: true, attributes: nil)
            
        } catch {
            XCTFail("Unexpected error: \(error)")
        }

        fileManager.createFile(atPath: actualFilePath, contents: actualData, attributes: nil)
        fileManager.createFile(atPath: expectedFilePath, contents: expectedData, attributes: nil)

        print("Execute the following to check the diffs:")
        print("diff \(actualFilePath) \(expectedFilePath)")
    }
}
