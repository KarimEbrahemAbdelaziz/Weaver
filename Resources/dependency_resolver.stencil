/// This file is generated by Weaver 0.9.13
/// DO NOT EDIT!

{% for moduleName in imports %}
import {{moduleName}}
{% endfor %}{# imports #}

{% for resolver in resolvers %}

// MARK: - {{resolver.targetType.name}}

{% if not resolver.isIsolated %}

final class {{resolver.targetType.name}}DependencyContainer{{resolver.targetType.generics}}: DependencyContainer {
    
    {% for parameter in resolver.parameters %}
    let {{parameter.name}}: {{parameter.type}}
    {% endfor %}

    init({% if not resolver.isRoot %}parent: Reference<DependencyContainer>? = nil{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.type}}{% if not forloop.last %}, {% endif %}{% endfor %}) {

        {% for parameter in resolver.parameters %}
        self.{{parameter.name}} = {{parameter.name}}
        {% endfor %}

        super.init({% if not resolver.isRoot %}parent{% endif %})
    }

    {# deinit {
        print("\({{resolver.targetType.name}}DependencyContainer{{resolver.targetType.generics}}.self): deinit")
    } #}

    override func registerDependencies(in store: DependencyStore) {
        
        {% for registration in resolver.registrations %}

        store.register({{registration.abstractType}}.self, scope: .{{registration.scope}}, name: "{{registration.name}}", builder: { (dependencies{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.type}}{% endfor %}) in
            {% if not registration.customRef %}

            return {{registration.type.name}}{{registration.abstractType.generics}}{% if registration.hasBuilder %}.make{{registration.type.name}}(injecting: dependencies{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.name}}{% endfor %}){% else %}(){% endif %}
            {% else %}{# not registration.customRef #}

            return self.{{registration.name}}CustomRef({% for parameter in registration.parameters %}{% if not forloop.first %}, {% endif %}{{parameter.name}}: {{parameter.name}}{% endfor %})
            {% endif %}{# not registration.customRef #}
        })

        {% endfor %}{# resolver.registrations #}
    }
}

{% endif %}{# not resolver.isIsolated #}

{% if resolver.doesSupportObjc %}@objc {% endif %}protocol {{resolver.targetType.name}}DependencyResolver {

    {% for genericName in resolver.targetType.genericNames %}
    associatedtype {{genericName}}
    {% endfor %}{# resolver.targetType.genericNames #}

    {% for parameter in resolver.parameters %}
    var {{parameter.name}}: {{parameter.type}} { get }
    {% endfor %}

    {% for reference in resolver.references %}

    {% if reference.parameters %}
    func {{reference.name}}({% for parameter in reference.parameters %}{{parameter.name}}: {{parameter.type}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{reference.abstractType}}
    {% else %}{# reference.parameters #}
    var {{reference.name}}: {{reference.abstractType}} { get }
    {% endif %}{# reference.parameters #}

    {% endfor %}{# resolver.references #}

    {% for registration in resolver.registrations %}

    {% if registration.customRef %}
    func {{registration.name}}CustomRef({% for parameter in registration.parameters %}{% if not forloop.first %}, {% endif %}{{parameter.name}}: {{parameter.type}}{% endfor %}) -> {{registration.abstractType}}
    {% endif %}{# registration.customRef #}

    {% endfor %}{# resolver.registrations  #}
}

{% if not resolver.isIsolated %}

extension {{resolver.targetType.name}}DependencyContainer: {{resolver.targetType.name}}DependencyResolver {
    {% for reference in resolver.references %}

    {% if reference.parameters %}

    func {{reference.name}}({% for parameter in reference.parameters %}{{parameter.name}}: {{parameter.type}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{reference.abstractType}} {
        return resolve({{reference.abstractType}}.self, name: "{{reference.name}}", parameter{% if reference.parameters.count > 1 %}s{% endif %}: {% for parameter in reference.parameters %}{{parameter.name}}{% if not forloop.last %}, {% endif %}{% endfor %})
    }

    {% else %}{# reference.paramters #}

    var {{reference.name}}: {{reference.abstractType}} {
        return resolve({{reference.abstractType}}.self, name: "{{reference.name}}")
    }

    {% endif %}{# reference.parameters #}

    {% endfor %}{# resolver.references #}
}

{% endif %}{# not resolver.isIsolated #}

{% if not resolver.isRoot %}

{% if not resolver.isIsolated %}

extension {% if resolver.enclosingTypeNames %}{{resolver.enclosingTypeNames|join: "."}}.{% endif %}{{resolver.targetType.name}} {

    static func make{{resolver.targetType.name}}({% if not resolver.isRoot %}injecting parentDependencies: DependencyContainer{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.type}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{resolver.targetType}} {

        let dependencies = {{resolver.targetType.name}}DependencyContainer{{resolver.targetType.generics}}({% if not resolver.isRoot %}parent: Reference(parentDependencies){% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.name}}{% if not forloop.last %}, {% endif %}{% endfor %})
        return {{resolver.targetType.name}}(injecting: dependencies)
        
    }
}

{% endif %}{# not resolver.isIsolated #}

protocol {{resolver.targetType.name}}{% if resolver.doesSupportObjc %}ObjC{% endif %}DependencyInjectable {
    {% for genericName in resolver.targetType.genericNames %}
    associatedtype {{genericName}}
    {% endfor %}{# resolver.targetType.genericNames #}

    {% if resolver.targetType.genericNames %}
    init(injecting dependencies: {{resolver.targetType.name}}DependencyContainer{{resolver.targetType.generics}})
    {% else %}{#resolver.targetType.genericNames#}
    init(injecting dependencies: {{resolver.targetType.name}}DependencyResolver)
    {% endif %}{#resolver.targetType.genericNames#}
}

{% if not resolver.doesSupportObjc %}

extension {% if resolver.enclosingTypeNames %}{{resolver.enclosingTypeNames|join: "."}}.{% endif %}{{resolver.targetType.name}}: {{resolver.targetType.name}}DependencyInjectable {}

{% endif %}{# not resolver.doesSupportObjc #}

{% endif %}{# not resolver.isRoot #}

{% if resolver.isPublic %}

// MARK: - {{resolver.targetType.name}}Shim

final class {{resolver.targetType.name}}ShimDependencyContainer{{resolver.targetType.generics}}: DependencyContainer {

    private lazy var internalDependencies: {{resolver.targetType.name}}DependencyContainer = {
        return {{resolver.targetType}}DependencyContainer({% if not resolver.isRoot %}parent: Reference(self, type: .weak){% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{ parameter.name }}: self.{{ parameter.name }}{% if not forloop.last %}, {% endif %}{% endfor %})
    }()
    
    {% for reference in resolver.publicReferences %}
    let {{ reference.name }}: {{ reference.type }}
    {% endfor %}{# resolver.publicReferences #}

    {% for parameter in resolver.parameters %}
    let {{parameter.name}}: {{parameter.type}}
    {% endfor %}{# resolver.parameters #}

    init({% for reference in resolver.publicReferences %}{% if not forloop.first %}, {% endif %}{{ reference.name }}: {{ reference.type }}{% endfor %}{% if resolver.publicReferences %}{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{% if not forloop.first %}, {% endif %}{{ parameter.name }}: {{ parameter.type }}{% endfor %}) {
        {% for reference in resolver.publicReferences %}
        self.{{ reference.name }} = {{ reference.name }}
        {% endfor %}{# resolver.publicReferences #}

        {% for parameter in resolver.parameters %}
        self.{{parameter.name}} = {{parameter.name}}
        {% endfor %}{# resolver.parameters #}        

        super.init()
    }

    {# deinit {
        print("\({{resolver.targetType.name}}ShimDependencyContainer{{resolver.targetType.generics}}.self): deinit")
    } #}

    override func registerDependencies(in store: DependencyStore) {
        {% for reference in resolver.publicReferences %}
        store.register({{reference.type}}.self, scope: .weak, name: "{{reference.name}}", builder: { [weak self] _ in
            guard let strongSelf = self else {
                fatalError("Container was released too early. If you see this happen, please file a bug.")
            }
            return strongSelf.{{reference.name}}
        })
        {% endfor %}{# resolver.publicReferences #}
    }
}

extension {{resolver.targetType.name}}ShimDependencyContainer: {{resolver.targetType.name}}DependencyResolver {
    {% for reference in resolver.internalReferences %}

    {% if reference.parameters %}

    func {{reference.name}}({% for parameter in reference.parameters %}{{parameter.name}}: {{parameter.type}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{reference.abstractType}} {
        return internalDependencies.resolve({{reference.abstractType.name}}.self, name: "{{reference.name}}", parameter{% if reference.parameters.count > 1 %}s{% endif %}: {% for parameter in reference.parameters %}{{parameter.name}}{% if not forloop.last %}, {% endif %}{% endfor %})
    }

    {% else %}{# reference.parameters #}

    var {{reference.name}}: {{reference.abstractType}} {
        return internalDependencies.resolve({{reference.abstractType}}.self, name: "{{reference.name}}")
    }

    {% endif %}{# reference.parameters #}

    {% endfor %}{# resolver.internalReferences #}
}

extension {{resolver.targetType.name}} {
    public convenience init({% for reference in resolver.publicReferences %}{% if not forloop.first %}, {% endif %}{{ reference.name }}: {{ reference.type }}{% endfor %}{% if resolver.publicReferences %}{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{% if not forloop.first %}, {% endif %}{{ parameter.name }}: {{ parameter.type }}{% endfor %}) {
        let shim = {{resolver.targetType.name}}ShimDependencyContainer({% for reference in resolver.publicReferences %}{% if not forloop.first %}, {% endif %}{{ reference.name }}: {{ reference.name }}{% endfor %}{% if resolver.publicReferences %}{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{% if not forloop.first %}, {% endif %}{{ parameter.name }}: {{ parameter.name }}{% endfor %})
        self.init(injecting: shim)
    }
}

{% endif %}{# resolver.isPublic #}

{% endfor %}{# resolvers #}
