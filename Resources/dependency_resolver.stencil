/// This file is generated by Weaver 0.9.10
/// DO NOT EDIT!

{% for moduleName in imports %}
import {{moduleName}}
{% endfor %}{# imports #}

{% for resolver in resolvers %}

// MARK: - {{resolver.targetTypeName}}

{% if not resolver.isIsolated %}

final class {{resolver.targetTypeName}}DependencyContainer: DependencyContainer {
    
    {% for parameter in resolver.parameters %}
    let {{parameter.name}}: {{parameter.typeName}}
    {% endfor %}

    init({% if not resolver.isRoot %}parent: DependencyContainer? = nil{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) {

        {% for parameter in resolver.parameters %}
        self.{{parameter.name}} = {{parameter.name}}
        {% endfor %}

        super.init({% if not resolver.isRoot %}parent{% endif %})
    }

    override func registerDependencies(in store: DependencyStore) {
        
        {% for registration in resolver.registrations %}

        store.register({{registration.abstractTypeName}}.self, scope: .{{registration.scope}}, name: "{{registration.name}}", builder: { (dependencies{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.typeName}}{% endfor %}) in
            {% if not registration.customRef %}

            return {{registration.typeName}}{% if registration.hasBuilder %}.make{{registration.typeName}}(injecting: dependencies{% for parameter in registration.parameters %}, {{parameter.name}}: {{parameter.name}}{% endfor %}){% else %}(){% endif %}
            {% else %}{# not registration.customRef #}

            return self.{{registration.name}}CustomRef({% for parameter in registration.parameters %}{% if not forloop.first %}, {% endif %}{{parameter.name}}: {{parameter.name}}{% endfor %})
            {% endif %}{# not registration.customRef #}
        })

        {% endfor %}{# resolver.registrations #}
    }
}

{% endif %}{# not resolver.isIsolated #}

{% if resolver.doesSupportObjc %}@objc {% endif %}protocol {{resolver.targetTypeName}}DependencyResolver {

    {% for parameter in resolver.parameters %}
    var {{parameter.name}}: {{parameter.typeName}} { get }
    {% endfor %}

    {% for reference in resolver.references %}

    {% if reference.parameters %}
    func {{reference.name}}({% for parameter in reference.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{reference.resolvedTypeName}}
    {% else %}{# reference.parameters #}
    var {{reference.name}}: {{reference.resolvedTypeName}} { get }
    {% endif %}{# reference.parameters #}

    {% endfor %}{# resolver.references #}

    {% for registration in resolver.registrations %}

    {% if registration.customRef %}
    func {{registration.name}}CustomRef({% for parameter in registration.parameters %}{% if not forloop.first %}, {% endif %}{{parameter.name}}: {{parameter.typeName}}{% endfor %}) -> {{registration.abstractTypeName}}
    {% endif %}{# registration.customRef #}

    {% endfor %}{# resolver.registrations  #}
}

{% if not resolver.isIsolated %}

extension {{resolver.targetTypeName}}DependencyContainer: {{resolver.targetTypeName}}DependencyResolver {
    {% for reference in resolver.references %}

    {% if reference.parameters %}

    func {{reference.name}}({% for parameter in reference.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{reference.resolvedTypeName}} {
        return resolve({{reference.resolvedTypeName}}.self, name: "{{reference.name}}", parameter{% if reference.parameters.count > 1 %}s{% endif %}: {% for parameter in reference.parameters %}{{parameter.name}}{% if not forloop.last %}, {% endif %}{% endfor %})
    }

    {% else %}{# reference.paramters #}

    var {{reference.name}}: {{reference.resolvedTypeName}} {
        return resolve({{reference.resolvedTypeName}}.self, name: "{{reference.name}}")
    }

    {% endif %}{# reference.parameters #}

    {% endfor %}{# resolver.references #}
}

{% endif %}{# not resolver.isIsolated #}

{% if not resolver.isRoot %}

{% if not resolver.isIsolated %}

extension {% if resolver.enclosingTypeNames %}{{resolver.enclosingTypeNames|join: "."}}.{% endif %}{{resolver.targetTypeName}} {

    static func make{{resolver.targetTypeName}}({% if not resolver.isRoot %}injecting parentDependencies: DependencyContainer{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{resolver.targetTypeName}} {

        let dependencies = {{resolver.targetTypeName}}DependencyContainer({% if not resolver.isRoot %}parent: parentDependencies{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{{parameter.name}}: {{parameter.name}}{% if not forloop.last %}, {% endif %}{% endfor %})
        return {{resolver.targetTypeName}}(injecting: dependencies)
        
    }
}

{% endif %}{# not resolver.isIsolated #}

protocol {{resolver.targetTypeName}}{% if resolver.doesSupportObjc %}ObjC{% endif %}DependencyInjectable {
    init(injecting dependencies: {{resolver.targetTypeName}}DependencyResolver)
}

{% if not resolver.doesSupportObjc %}

extension {% if resolver.enclosingTypeNames %}{{resolver.enclosingTypeNames|join: "."}}.{% endif %}{{resolver.targetTypeName}}: {{resolver.targetTypeName}}DependencyInjectable {}

{% endif %}{# not resolver.doesSupportObjc #}

{% endif %}{# not resolver.isRoot #}

{% if resolver.isPublic %}

// MARK: - {{resolver.targetTypeName}}Shim

final class {{resolver.targetTypeName}}ShimDependencyContainer {

    private let internalDependencies: {{resolver.targetTypeName}}DependencyContainer
    
    {% for reference in resolver.publicReferences %}
    let {{ reference.name }}: {{ reference.typeName }}
    {% endfor %}{# resolver.publicReferences #}

    init({% for reference in resolver.publicReferences %}{% if not forloop.first %}, {% endif %}{{ reference.name }}: {{ reference.typeName }}{% endfor %}{% if resolver.publicReferences %}{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{% if not forloop.first %}, {% endif %}{{ parameter.name }}: {{ parameter.typeName }}{% endfor %}) {
        internalDependencies = {{resolver.targetTypeName}}DependencyContainer({% for parameter in resolver.parameters %}{% if not forloop.last %}, {% endif %}{{ parameter.name }}: {{ parameter.name }}{% endfor %})

        {% for reference in resolver.publicReferences %}
        self.{{ reference.name }} = {{ reference.name }}
        {% endfor %}{# resolver.publicReferences #}
    }
}

extension {{resolver.targetTypeName}}ShimDependencyContainer: {{resolver.targetTypeName}}DependencyResolver {
    {% for reference in resolver.internalReferences %}

    {% if reference.parameters %}

    func {{reference.name}}({% for parameter in reference.parameters %}{{parameter.name}}: {{parameter.typeName}}{% if not forloop.last %}, {% endif %}{% endfor %}) -> {{reference.resolvedTypeName}} {
        return internalDependencies.resolve({{reference.resolvedTypeName}}.self, name: "{{reference.name}}", parameter{% if reference.parameters.count > 1 %}s{% endif %}: {% for parameter in reference.parameters %}{{parameter.name}}{% if not forloop.last %}, {% endif %}{% endfor %})
    }

    {% else %}{# reference.parameters #}

    var {{reference.name}}: {{reference.resolvedTypeName}} {
        return internalDependencies.resolve({{reference.resolvedTypeName}}.self, name: "{{reference.name}}")
    }

    {% endif %}{# reference.parameters #}

    {% endfor %}{# resolver.internalReferences #}

    {% for parameter in resolver.parameters %}

    var {{parameter.name}}: {{parameter.typeName}} {
        return internalDependencies.{{parameter.name}}
    }

    {% endfor %}{# resolver.parameters #}
}

extension {{resolver.targetTypeName}} {
    public convenience init({% for reference in resolver.publicReferences %}{% if not forloop.first %}, {% endif %}{{ reference.name }}: {{ reference.typeName }}{% endfor %}{% if resolver.publicReferences %}{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{% if not forloop.first %}, {% endif %}{{ parameter.name }}: {{ parameter.typeName }}{% endfor %}) {
        let shim = {{resolver.targetTypeName}}ShimDependencyContainer({% for reference in resolver.publicReferences %}{% if not forloop.first %}, {% endif %}{{ reference.name }}: {{ reference.name }}{% endfor %}{% if resolver.publicReferences %}{% if resolver.parameters %}, {% endif %}{% endif %}{% for parameter in resolver.parameters %}{% if not forloop.first %}, {% endif %}{{ parameter.name }}: {{ parameter.name }}{% endfor %})
        self.init(injecting: shim)
    }
}

{% endif %}{# resolver.isPublic #}

{% endfor %}{# resolvers #}
